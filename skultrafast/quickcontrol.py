"""
Module to import and work with files generated by QuickControl from phasetech.
"""
from scipy.constants import speed_of_light
import numpy as np
from typing import Dict, List, Iterable
from pathlib import Path
import attr

from skultrafast.dataset import PolTRSpec, TimeResSpec


def parse_str(s: str):
    if s.isnumeric():
        return int(s)
    elif set(s) - set('-.0123456789E') == set():
        # Try is a workaround for the version string
        try:
            return float(s)
        except ValueError:
            return s
    elif set(s) - set('-.0123456789E,') == set():
        return list(map(float, s.split(',')))
    elif s == 'TRUE':
        return True
    elif s == 'FALSE':
        return False
    else:
        return s


@attr.s(auto_attribs=True)
class QCFile:
    fname: str = attr.ib()
    path: Path = attr.ib()
    prefix: str = attr.ib()
    info: dict = attr.ib()

    @path.default
    def _path(self):
        return Path(self.fname).parent

    @prefix.default
    def _prefix(self):
        return Path(self.fname).with_suffix('').name

    @info.default
    def _load_info(self):
        h = []
        d = {}
        with (self.path / self.prefix).with_suffix('.info').open() as i:
            for l in i:
                key, val = l.split('\t')
                val = val[:-1].strip()
                d[key] = parse_str(val)
        return d


@attr.s
class QCTimeRes(QCFile):
    t: Iterable[float] = attr.ib()
    wavelength: np.ndarray = attr.ib()

    @t.default
    def _t_default(self):
        t_list = self.info['Delays']
        return np.array(t_list) / 1000.

    @wavelength.default
    def calc_wl(self, disp=None):
        if disp is None:
            grating = self.info['MONO1 Grating']
            disp_per_grating = {'30': 7.7, '75': 7.7 * 30 / 75.}
            disp = disp_per_grating[grating.split()[2]]
        wls = (np.arange(128) - 64) * disp + self.info['MONO1 Wavelength']
        self.wavelength = wls
        return wls


class QC1DSpec(QCTimeRes):
    par_data: np.ndarray = attr.ib()
    per_data: np.ndarray = attr.ib()

    @par_data.default
    def _load_par(self):
        par_scan_files = self.path.glob(self.prefix + '*_PAR*.scan')
        return np.array([np.loadtxt(p)[:-1, 1:] for p in par_scan_files])

    @per_data.default
    def _load_per(self):
        per_scan_files = self.path.glob(self.prefix + '*_PER*.scan')
        return np.array([np.loadtxt(p)[:-1, 1:] for p in per_scan_files])

    def make_pol_ds(self, sigma=None) -> PolTRSpec:
        para = np.nanmean(self.par_data, axis=0)
        ds_para = TimeResSpec(self.wavelength, self.t, 1000 * para, disp_freq_unit='cm')
        perp = np.nanmean(self.per_data, axis=0)
        ds_perp = TimeResSpec(self.wavelength, self.t, 1000 * perp, disp_freq_unit='cm')
        return PolTRSpec(ds_para, ds_perp)


@attr.s(auto_attribs=True)
class QC2DSpec(QCTimeRes):
    t1: np.ndarray = attr.ib()
    par_data: Dict = attr.ib()
    per_data: Dict = attr.ib()
    pump_freq: np.ndarray = attr.ib()

    @t1.default
    def _load_t1(self):
        return np.loadtxt((self.path / self.prefix).with_suffix('.wts'))

    @par_data.default
    def _load_par(self):
        data = {}
        self.spec2d = []
        for t in range(len(self.t1)):
            T = '_T%02d' % (t+1)
            par_scans = self.path.glob(self.prefix + T + '_PER*.scan')
            data[t] = []
            for s in par_scans:
                d = np.loadtxt(s)
                self.t2 = d[1:, 0]
                data[t].append(d)
            data[t] = d = np.array(data[t])
            d = d.mean(0)
            d = d[:-1, 1:]
            d[0, :] *= 0.5
            win = np.hamming(2 * len(self.t1))
            spec2d = np.fft.rfft(d * win[len(self.t1):, None], axis=0, n=2 * len(self.t1))
            self.spec2d.append(spec2d)

    @per_data.default
    def _load_per(self):
        pass

    @pump_freq.default
    def _calc_freqs(self):
        freqs = np.fft.rfftfreq(2 * len(self.t1), self.t1[1] - self.t1[0])
        cm = 0.01 / ((1/freqs) * 1e-15 * speed_of_light)
        return cm
